/* tslint:disable */
/* eslint-disable */
/**
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Basket model serializer
 * @export
 * @interface Basket
 */
export interface Basket {
    /**
     *
     * @type {number}
     * @memberof Basket
     */
    'id': number;
    /**
     *
     * @type {number}
     * @memberof Basket
     */
    'user': number;
    /**
     *
     * @type {string}
     * @memberof Basket
     */
    'basket_items': string;
}
/**
 * BasketItem model serializer
 * @export
 * @interface BasketItem
 */
export interface BasketItem {
    /**
     *
     * @type {number}
     * @memberof BasketItem
     */
    'basket': number;
    /**
     *
     * @type {number}
     * @memberof BasketItem
     */
    'product': number;
    /**
     *
     * @type {number}
     * @memberof BasketItem
     */
    'id': number;
}
/**
 * Serializer for IntegratedSystem model.
 * @export
 * @interface IntegratedSystem
 */
export interface IntegratedSystem {
    /**
     *
     * @type {number}
     * @memberof IntegratedSystem
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof IntegratedSystem
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof IntegratedSystem
     */
    'slug'?: string | null;
    /**
     *
     * @type {string}
     * @memberof IntegratedSystem
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface PaginatedBasketItemList
 */
export interface PaginatedBasketItemList {
    /**
     *
     * @type {number}
     * @memberof PaginatedBasketItemList
     */
    'count'?: number;
    /**
     *
     * @type {string}
     * @memberof PaginatedBasketItemList
     */
    'next'?: string | null;
    /**
     *
     * @type {string}
     * @memberof PaginatedBasketItemList
     */
    'previous'?: string | null;
    /**
     *
     * @type {Array<BasketItem>}
     * @memberof PaginatedBasketItemList
     */
    'results'?: Array<BasketItem>;
}
/**
 *
 * @export
 * @interface PaginatedBasketList
 */
export interface PaginatedBasketList {
    /**
     *
     * @type {number}
     * @memberof PaginatedBasketList
     */
    'count'?: number;
    /**
     *
     * @type {string}
     * @memberof PaginatedBasketList
     */
    'next'?: string | null;
    /**
     *
     * @type {string}
     * @memberof PaginatedBasketList
     */
    'previous'?: string | null;
    /**
     *
     * @type {Array<Basket>}
     * @memberof PaginatedBasketList
     */
    'results'?: Array<Basket>;
}
/**
 *
 * @export
 * @interface PaginatedIntegratedSystemList
 */
export interface PaginatedIntegratedSystemList {
    /**
     *
     * @type {number}
     * @memberof PaginatedIntegratedSystemList
     */
    'count'?: number;
    /**
     *
     * @type {string}
     * @memberof PaginatedIntegratedSystemList
     */
    'next'?: string | null;
    /**
     *
     * @type {string}
     * @memberof PaginatedIntegratedSystemList
     */
    'previous'?: string | null;
    /**
     *
     * @type {Array<IntegratedSystem>}
     * @memberof PaginatedIntegratedSystemList
     */
    'results'?: Array<IntegratedSystem>;
}
/**
 *
 * @export
 * @interface PaginatedProductList
 */
export interface PaginatedProductList {
    /**
     *
     * @type {number}
     * @memberof PaginatedProductList
     */
    'count'?: number;
    /**
     *
     * @type {string}
     * @memberof PaginatedProductList
     */
    'next'?: string | null;
    /**
     *
     * @type {string}
     * @memberof PaginatedProductList
     */
    'previous'?: string | null;
    /**
     *
     * @type {Array<Product>}
     * @memberof PaginatedProductList
     */
    'results'?: Array<Product>;
}
/**
 * Serializer for IntegratedSystem model.
 * @export
 * @interface PatchedIntegratedSystem
 */
export interface PatchedIntegratedSystem {
    /**
     *
     * @type {number}
     * @memberof PatchedIntegratedSystem
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof PatchedIntegratedSystem
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedIntegratedSystem
     */
    'slug'?: string | null;
    /**
     *
     * @type {string}
     * @memberof PatchedIntegratedSystem
     */
    'description'?: string;
}
/**
 * Serializer for Product model.
 * @export
 * @interface PatchedProduct
 */
export interface PatchedProduct {
    /**
     *
     * @type {number}
     * @memberof PatchedProduct
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof PatchedProduct
     */
    'deleted_on'?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof PatchedProduct
     */
    'deleted_by_cascade'?: boolean;
    /**
     *
     * @type {string}
     * @memberof PatchedProduct
     */
    'created_on'?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedProduct
     */
    'updated_on'?: string;
    /**
     * SKU of the product.
     * @type {string}
     * @memberof PatchedProduct
     */
    'sku'?: string;
    /**
     * Short name of the product, displayed in carts/etc.
     * @type {string}
     * @memberof PatchedProduct
     */
    'name'?: string;
    /**
     * Price (decimal to two places)
     * @type {string}
     * @memberof PatchedProduct
     */
    'price'?: string;
    /**
     * Long description of the product.
     * @type {string}
     * @memberof PatchedProduct
     */
    'description'?: string;
    /**
     * System-specific data for the product (in JSON).
     * @type {any}
     * @memberof PatchedProduct
     */
    'system_data'?: any | null;
    /**
     * Owner system of the product.
     * @type {number}
     * @memberof PatchedProduct
     */
    'system'?: number;
}
/**
 * Serializer for Product model.
 * @export
 * @interface Product
 */
export interface Product {
    /**
     *
     * @type {number}
     * @memberof Product
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof Product
     */
    'deleted_on': string | null;
    /**
     *
     * @type {boolean}
     * @memberof Product
     */
    'deleted_by_cascade': boolean;
    /**
     *
     * @type {string}
     * @memberof Product
     */
    'created_on': string;
    /**
     *
     * @type {string}
     * @memberof Product
     */
    'updated_on': string;
    /**
     * SKU of the product.
     * @type {string}
     * @memberof Product
     */
    'sku': string;
    /**
     * Short name of the product, displayed in carts/etc.
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * Price (decimal to two places)
     * @type {string}
     * @memberof Product
     */
    'price': string;
    /**
     * Long description of the product.
     * @type {string}
     * @memberof Product
     */
    'description': string;
    /**
     * System-specific data for the product (in JSON).
     * @type {any}
     * @memberof Product
     */
    'system_data'?: any | null;
    /**
     * Owner system of the product.
     * @type {number}
     * @memberof Product
     */
    'system': number;
}

/**
 * MetaApi - axios parameter creator
 * @export
 */
export const MetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Test API request so we can see how the APISIX integration works.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaApisixTestRequestRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/meta/apisix_test_request/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test API request so we can see how the Traefik integration works.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAuthedTraefikTestRequestRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/meta/authed_traefik_test_request/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {IntegratedSystem} IntegratedSystem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemCreate: async (IntegratedSystem: IntegratedSystem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'IntegratedSystem' is not null or undefined
            assertParamExists('metaIntegratedSystemCreate', 'IntegratedSystem', IntegratedSystem)
            const localVarPath = `/api/v0/meta/integrated_system/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(IntegratedSystem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {number} id A unique integer value identifying this integrated system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaIntegratedSystemDestroy', 'id', id)
            const localVarPath = `/api/v0/meta/integrated_system/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/meta/integrated_system/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {number} id A unique integer value identifying this integrated system.
         * @param {PatchedIntegratedSystem} [PatchedIntegratedSystem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemPartialUpdate: async (id: number, PatchedIntegratedSystem?: PatchedIntegratedSystem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaIntegratedSystemPartialUpdate', 'id', id)
            const localVarPath = `/api/v0/meta/integrated_system/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedIntegratedSystem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {number} id A unique integer value identifying this integrated system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaIntegratedSystemRetrieve', 'id', id)
            const localVarPath = `/api/v0/meta/integrated_system/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {number} id A unique integer value identifying this integrated system.
         * @param {IntegratedSystem} IntegratedSystem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemUpdate: async (id: number, IntegratedSystem: IntegratedSystem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaIntegratedSystemUpdate', 'id', id)
            // verify required parameter 'IntegratedSystem' is not null or undefined
            assertParamExists('metaIntegratedSystemUpdate', 'IntegratedSystem', IntegratedSystem)
            const localVarPath = `/api/v0/meta/integrated_system/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(IntegratedSystem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for Product model.
         * @param {Product} Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductCreate: async (Product: Product, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'Product' is not null or undefined
            assertParamExists('metaProductCreate', 'Product', Product)
            const localVarPath = `/api/v0/meta/product/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(Product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for Product model.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaProductDestroy', 'id', id)
            const localVarPath = `/api/v0/meta/product/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for Product model.
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name]
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [system__slug]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductList: async (limit?: number, name?: string, offset?: number, system__slug?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/meta/product/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (system__slug !== undefined) {
                localVarQueryParameter['system__slug'] = system__slug;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for Product model.
         * @param {number} id A unique integer value identifying this product.
         * @param {PatchedProduct} [PatchedProduct]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductPartialUpdate: async (id: number, PatchedProduct?: PatchedProduct, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaProductPartialUpdate', 'id', id)
            const localVarPath = `/api/v0/meta/product/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedProduct, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for Product model.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaProductRetrieve', 'id', id)
            const localVarPath = `/api/v0/meta/product/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for Product model.
         * @param {number} id A unique integer value identifying this product.
         * @param {Product} Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductUpdate: async (id: number, Product: Product, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metaProductUpdate', 'id', id)
            // verify required parameter 'Product' is not null or undefined
            assertParamExists('metaProductUpdate', 'Product', Product)
            const localVarPath = `/api/v0/meta/product/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(Product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test API request so we can see how the Traefik integration works.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaTraefikTestRequestRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/meta/traefik_test_request/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetaApi - functional programming interface
 * @export
 */
export const MetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Test API request so we can see how the APISIX integration works.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaApisixTestRequestRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaApisixTestRequestRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test API request so we can see how the Traefik integration works.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaAuthedTraefikTestRequestRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaAuthedTraefikTestRequestRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {IntegratedSystem} IntegratedSystem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaIntegratedSystemCreate(IntegratedSystem: IntegratedSystem, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegratedSystem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaIntegratedSystemCreate(IntegratedSystem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {number} id A unique integer value identifying this integrated system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaIntegratedSystemDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaIntegratedSystemDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaIntegratedSystemList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIntegratedSystemList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaIntegratedSystemList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {number} id A unique integer value identifying this integrated system.
         * @param {PatchedIntegratedSystem} [PatchedIntegratedSystem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaIntegratedSystemPartialUpdate(id: number, PatchedIntegratedSystem?: PatchedIntegratedSystem, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegratedSystem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaIntegratedSystemPartialUpdate(id, PatchedIntegratedSystem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {number} id A unique integer value identifying this integrated system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaIntegratedSystemRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegratedSystem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaIntegratedSystemRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {number} id A unique integer value identifying this integrated system.
         * @param {IntegratedSystem} IntegratedSystem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaIntegratedSystemUpdate(id: number, IntegratedSystem: IntegratedSystem, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegratedSystem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaIntegratedSystemUpdate(id, IntegratedSystem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for Product model.
         * @param {Product} Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaProductCreate(Product: Product, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaProductCreate(Product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for Product model.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaProductDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaProductDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for Product model.
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name]
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [system__slug]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaProductList(limit?: number, name?: string, offset?: number, system__slug?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaProductList(limit, name, offset, system__slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for Product model.
         * @param {number} id A unique integer value identifying this product.
         * @param {PatchedProduct} [PatchedProduct]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaProductPartialUpdate(id: number, PatchedProduct?: PatchedProduct, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaProductPartialUpdate(id, PatchedProduct, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for Product model.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaProductRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaProductRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for Product model.
         * @param {number} id A unique integer value identifying this product.
         * @param {Product} Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaProductUpdate(id: number, Product: Product, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaProductUpdate(id, Product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test API request so we can see how the Traefik integration works.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaTraefikTestRequestRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaTraefikTestRequestRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetaApi - factory interface
 * @export
 */
export const MetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetaApiFp(configuration)
    return {
        /**
         * Test API request so we can see how the APISIX integration works.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaApisixTestRequestRetrieve(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metaApisixTestRequestRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Test API request so we can see how the Traefik integration works.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaAuthedTraefikTestRequestRetrieve(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metaAuthedTraefikTestRequestRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {MetaApiMetaIntegratedSystemCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemCreate(requestParameters: MetaApiMetaIntegratedSystemCreateRequest, options?: AxiosRequestConfig): AxiosPromise<IntegratedSystem> {
            return localVarFp.metaIntegratedSystemCreate(requestParameters.IntegratedSystem, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {MetaApiMetaIntegratedSystemDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemDestroy(requestParameters: MetaApiMetaIntegratedSystemDestroyRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metaIntegratedSystemDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {MetaApiMetaIntegratedSystemListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemList(requestParameters: MetaApiMetaIntegratedSystemListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaginatedIntegratedSystemList> {
            return localVarFp.metaIntegratedSystemList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {MetaApiMetaIntegratedSystemPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemPartialUpdate(requestParameters: MetaApiMetaIntegratedSystemPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<IntegratedSystem> {
            return localVarFp.metaIntegratedSystemPartialUpdate(requestParameters.id, requestParameters.PatchedIntegratedSystem, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {MetaApiMetaIntegratedSystemRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemRetrieve(requestParameters: MetaApiMetaIntegratedSystemRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<IntegratedSystem> {
            return localVarFp.metaIntegratedSystemRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for IntegratedSystem model.
         * @param {MetaApiMetaIntegratedSystemUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaIntegratedSystemUpdate(requestParameters: MetaApiMetaIntegratedSystemUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<IntegratedSystem> {
            return localVarFp.metaIntegratedSystemUpdate(requestParameters.id, requestParameters.IntegratedSystem, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for Product model.
         * @param {MetaApiMetaProductCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductCreate(requestParameters: MetaApiMetaProductCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.metaProductCreate(requestParameters.Product, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for Product model.
         * @param {MetaApiMetaProductDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductDestroy(requestParameters: MetaApiMetaProductDestroyRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metaProductDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for Product model.
         * @param {MetaApiMetaProductListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductList(requestParameters: MetaApiMetaProductListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaginatedProductList> {
            return localVarFp.metaProductList(requestParameters.limit, requestParameters.name, requestParameters.offset, requestParameters.system__slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for Product model.
         * @param {MetaApiMetaProductPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductPartialUpdate(requestParameters: MetaApiMetaProductPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.metaProductPartialUpdate(requestParameters.id, requestParameters.PatchedProduct, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for Product model.
         * @param {MetaApiMetaProductRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductRetrieve(requestParameters: MetaApiMetaProductRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.metaProductRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for Product model.
         * @param {MetaApiMetaProductUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaProductUpdate(requestParameters: MetaApiMetaProductUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.metaProductUpdate(requestParameters.id, requestParameters.Product, options).then((request) => request(axios, basePath));
        },
        /**
         * Test API request so we can see how the Traefik integration works.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaTraefikTestRequestRetrieve(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metaTraefikTestRequestRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for metaIntegratedSystemCreate operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemCreateRequest
 */
export interface MetaApiMetaIntegratedSystemCreateRequest {
    /**
     *
     * @type {IntegratedSystem}
     * @memberof MetaApiMetaIntegratedSystemCreate
     */
    readonly IntegratedSystem: IntegratedSystem
}

/**
 * Request parameters for metaIntegratedSystemDestroy operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemDestroyRequest
 */
export interface MetaApiMetaIntegratedSystemDestroyRequest {
    /**
     * A unique integer value identifying this integrated system.
     * @type {number}
     * @memberof MetaApiMetaIntegratedSystemDestroy
     */
    readonly id: number
}

/**
 * Request parameters for metaIntegratedSystemList operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemListRequest
 */
export interface MetaApiMetaIntegratedSystemListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof MetaApiMetaIntegratedSystemList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof MetaApiMetaIntegratedSystemList
     */
    readonly offset?: number
}

/**
 * Request parameters for metaIntegratedSystemPartialUpdate operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemPartialUpdateRequest
 */
export interface MetaApiMetaIntegratedSystemPartialUpdateRequest {
    /**
     * A unique integer value identifying this integrated system.
     * @type {number}
     * @memberof MetaApiMetaIntegratedSystemPartialUpdate
     */
    readonly id: number

    /**
     *
     * @type {PatchedIntegratedSystem}
     * @memberof MetaApiMetaIntegratedSystemPartialUpdate
     */
    readonly PatchedIntegratedSystem?: PatchedIntegratedSystem
}

/**
 * Request parameters for metaIntegratedSystemRetrieve operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemRetrieveRequest
 */
export interface MetaApiMetaIntegratedSystemRetrieveRequest {
    /**
     * A unique integer value identifying this integrated system.
     * @type {number}
     * @memberof MetaApiMetaIntegratedSystemRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for metaIntegratedSystemUpdate operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemUpdateRequest
 */
export interface MetaApiMetaIntegratedSystemUpdateRequest {
    /**
     * A unique integer value identifying this integrated system.
     * @type {number}
     * @memberof MetaApiMetaIntegratedSystemUpdate
     */
    readonly id: number

    /**
     *
     * @type {IntegratedSystem}
     * @memberof MetaApiMetaIntegratedSystemUpdate
     */
    readonly IntegratedSystem: IntegratedSystem
}

/**
 * Request parameters for metaProductCreate operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductCreateRequest
 */
export interface MetaApiMetaProductCreateRequest {
    /**
     *
     * @type {Product}
     * @memberof MetaApiMetaProductCreate
     */
    readonly Product: Product
}

/**
 * Request parameters for metaProductDestroy operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductDestroyRequest
 */
export interface MetaApiMetaProductDestroyRequest {
    /**
     * A unique integer value identifying this product.
     * @type {number}
     * @memberof MetaApiMetaProductDestroy
     */
    readonly id: number
}

/**
 * Request parameters for metaProductList operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductListRequest
 */
export interface MetaApiMetaProductListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof MetaApiMetaProductList
     */
    readonly limit?: number

    /**
     *
     * @type {string}
     * @memberof MetaApiMetaProductList
     */
    readonly name?: string

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof MetaApiMetaProductList
     */
    readonly offset?: number

    /**
     *
     * @type {string}
     * @memberof MetaApiMetaProductList
     */
    readonly system__slug?: string
}

/**
 * Request parameters for metaProductPartialUpdate operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductPartialUpdateRequest
 */
export interface MetaApiMetaProductPartialUpdateRequest {
    /**
     * A unique integer value identifying this product.
     * @type {number}
     * @memberof MetaApiMetaProductPartialUpdate
     */
    readonly id: number

    /**
     *
     * @type {PatchedProduct}
     * @memberof MetaApiMetaProductPartialUpdate
     */
    readonly PatchedProduct?: PatchedProduct
}

/**
 * Request parameters for metaProductRetrieve operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductRetrieveRequest
 */
export interface MetaApiMetaProductRetrieveRequest {
    /**
     * A unique integer value identifying this product.
     * @type {number}
     * @memberof MetaApiMetaProductRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for metaProductUpdate operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductUpdateRequest
 */
export interface MetaApiMetaProductUpdateRequest {
    /**
     * A unique integer value identifying this product.
     * @type {number}
     * @memberof MetaApiMetaProductUpdate
     */
    readonly id: number

    /**
     *
     * @type {Product}
     * @memberof MetaApiMetaProductUpdate
     */
    readonly Product: Product
}

/**
 * MetaApi - object-oriented interface
 * @export
 * @class MetaApi
 * @extends {BaseAPI}
 */
export class MetaApi extends BaseAPI {
    /**
     * Test API request so we can see how the APISIX integration works.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaApisixTestRequestRetrieve(options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaApisixTestRequestRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test API request so we can see how the Traefik integration works.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaAuthedTraefikTestRequestRetrieve(options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaAuthedTraefikTestRequestRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaIntegratedSystemCreate(requestParameters: MetaApiMetaIntegratedSystemCreateRequest, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaIntegratedSystemCreate(requestParameters.IntegratedSystem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaIntegratedSystemDestroy(requestParameters: MetaApiMetaIntegratedSystemDestroyRequest, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaIntegratedSystemDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaIntegratedSystemList(requestParameters: MetaApiMetaIntegratedSystemListRequest = {}, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaIntegratedSystemList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaIntegratedSystemPartialUpdate(requestParameters: MetaApiMetaIntegratedSystemPartialUpdateRequest, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaIntegratedSystemPartialUpdate(requestParameters.id, requestParameters.PatchedIntegratedSystem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaIntegratedSystemRetrieve(requestParameters: MetaApiMetaIntegratedSystemRetrieveRequest, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaIntegratedSystemRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaIntegratedSystemUpdate(requestParameters: MetaApiMetaIntegratedSystemUpdateRequest, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaIntegratedSystemUpdate(requestParameters.id, requestParameters.IntegratedSystem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaProductCreate(requestParameters: MetaApiMetaProductCreateRequest, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaProductCreate(requestParameters.Product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaProductDestroy(requestParameters: MetaApiMetaProductDestroyRequest, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaProductDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaProductList(requestParameters: MetaApiMetaProductListRequest = {}, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaProductList(requestParameters.limit, requestParameters.name, requestParameters.offset, requestParameters.system__slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaProductPartialUpdate(requestParameters: MetaApiMetaProductPartialUpdateRequest, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaProductPartialUpdate(requestParameters.id, requestParameters.PatchedProduct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaProductRetrieve(requestParameters: MetaApiMetaProductRetrieveRequest, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaProductRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaProductUpdate(requestParameters: MetaApiMetaProductUpdateRequest, options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaProductUpdate(requestParameters.id, requestParameters.Product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test API request so we can see how the Traefik integration works.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaTraefikTestRequestRetrieve(options?: AxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaTraefikTestRequestRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Clear the basket for the current user.  Returns:     Response: HTTP response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsClearDestroy: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/payments/baskets/clear/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new basket item from a product for the currently logged in user. Reuse the existing basket object if it exists.  If the checkout flag is set in the POST data, then this will create the basket, then immediately flip the user to the checkout interstitial (which then redirects to the payment gateway).  Args:     system_slug (str): system slug     sku (str): product slug  POST Args:     quantity (int): quantity of the product to add to the basket (defaults to 1)     checkout (bool): redirect to checkout interstitial (defaults to False)  Returns:     Response: HTTP response
         * @param {string} sku
         * @param {string} system_slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsCreateFromProductCreate: async (sku: string, system_slug: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('paymentsBasketsCreateFromProductCreate', 'sku', sku)
            // verify required parameter 'system_slug' is not null or undefined
            assertParamExists('paymentsBasketsCreateFromProductCreate', 'system_slug', system_slug)
            const localVarPath = `/api/v0/payments/baskets/create_from_product/{system_slug}/{sku}/`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"system_slug"}}`, encodeURIComponent(String(system_slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new basket item.  Args:     request (HttpRequest): HTTP request  Returns:     Response: HTTP response
         * @param {string} basket
         * @param {BasketItem} BasketItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsItemsCreate: async (basket: string, BasketItem: BasketItem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'basket' is not null or undefined
            assertParamExists('paymentsBasketsItemsCreate', 'basket', basket)
            // verify required parameter 'BasketItem' is not null or undefined
            assertParamExists('paymentsBasketsItemsCreate', 'BasketItem', BasketItem)
            const localVarPath = `/api/v0/payments/baskets/{basket}/items/`
                .replace(`{${"basket"}}`, encodeURIComponent(String(basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(BasketItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for BasketItem
         * @param {string} basket
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsItemsDestroy: async (basket: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'basket' is not null or undefined
            assertParamExists('paymentsBasketsItemsDestroy', 'basket', basket)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentsBasketsItemsDestroy', 'id', id)
            const localVarPath = `/api/v0/payments/baskets/{basket}/items/{id}/`
                .replace(`{${"basket"}}`, encodeURIComponent(String(basket)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for BasketItem
         * @param {string} basket
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsItemsList: async (basket: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'basket' is not null or undefined
            assertParamExists('paymentsBasketsItemsList', 'basket', basket)
            const localVarPath = `/api/v0/payments/baskets/{basket}/items/`
                .replace(`{${"basket"}}`, encodeURIComponent(String(basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Basket
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/payments/baskets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view set for Basket
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsRetrieve: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('paymentsBasketsRetrieve', 'username', username)
            const localVarPath = `/api/v0/payments/baskets/{username}/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle webhook call from the payment gateway when the user has completed a transaction.  Returns:     - HTTP_200_OK if the Order is found.  Raises:     - Http404 if the Order is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCheckoutCallbackCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/payments/checkout/callback/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start the checkout process. This assembles the basket items into an Order with Lines for each item, applies the attached basket discounts, and then calls the payment gateway to prepare for payment.  This is expected to be called from within the Ecommerce cart app, not from an integrated system.  Returns:     - JSON payload from the ol-django payment gateway app. The payment       gateway returns data necessary to construct a form that will       ultimately POST to the actual payment processor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCheckoutStartCheckoutCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v0/payments/checkout/start_checkout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Clear the basket for the current user.  Returns:     Response: HTTP response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsBasketsClearDestroy(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsBasketsClearDestroy(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new basket item from a product for the currently logged in user. Reuse the existing basket object if it exists.  If the checkout flag is set in the POST data, then this will create the basket, then immediately flip the user to the checkout interstitial (which then redirects to the payment gateway).  Args:     system_slug (str): system slug     sku (str): product slug  POST Args:     quantity (int): quantity of the product to add to the basket (defaults to 1)     checkout (bool): redirect to checkout interstitial (defaults to False)  Returns:     Response: HTTP response
         * @param {string} sku
         * @param {string} system_slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsBasketsCreateFromProductCreate(sku: string, system_slug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsBasketsCreateFromProductCreate(sku, system_slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new basket item.  Args:     request (HttpRequest): HTTP request  Returns:     Response: HTTP response
         * @param {string} basket
         * @param {BasketItem} BasketItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsBasketsItemsCreate(basket: string, BasketItem: BasketItem, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsBasketsItemsCreate(basket, BasketItem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API view set for BasketItem
         * @param {string} basket
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsBasketsItemsDestroy(basket: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsBasketsItemsDestroy(basket, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API view set for BasketItem
         * @param {string} basket
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsBasketsItemsList(basket: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBasketItemList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsBasketsItemsList(basket, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API view set for Basket
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsBasketsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBasketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsBasketsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API view set for Basket
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsBasketsRetrieve(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Basket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsBasketsRetrieve(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Handle webhook call from the payment gateway when the user has completed a transaction.  Returns:     - HTTP_200_OK if the Order is found.  Raises:     - Http404 if the Order is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsCheckoutCallbackCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsCheckoutCallbackCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start the checkout process. This assembles the basket items into an Order with Lines for each item, applies the attached basket discounts, and then calls the payment gateway to prepare for payment.  This is expected to be called from within the Ecommerce cart app, not from an integrated system.  Returns:     - JSON payload from the ol-django payment gateway app. The payment       gateway returns data necessary to construct a form that will       ultimately POST to the actual payment processor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsCheckoutStartCheckoutCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsCheckoutStartCheckoutCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * Clear the basket for the current user.  Returns:     Response: HTTP response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsClearDestroy(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.paymentsBasketsClearDestroy(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new basket item from a product for the currently logged in user. Reuse the existing basket object if it exists.  If the checkout flag is set in the POST data, then this will create the basket, then immediately flip the user to the checkout interstitial (which then redirects to the payment gateway).  Args:     system_slug (str): system slug     sku (str): product slug  POST Args:     quantity (int): quantity of the product to add to the basket (defaults to 1)     checkout (bool): redirect to checkout interstitial (defaults to False)  Returns:     Response: HTTP response
         * @param {PaymentsApiPaymentsBasketsCreateFromProductCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsCreateFromProductCreate(requestParameters: PaymentsApiPaymentsBasketsCreateFromProductCreateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.paymentsBasketsCreateFromProductCreate(requestParameters.sku, requestParameters.system_slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new basket item.  Args:     request (HttpRequest): HTTP request  Returns:     Response: HTTP response
         * @param {PaymentsApiPaymentsBasketsItemsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsItemsCreate(requestParameters: PaymentsApiPaymentsBasketsItemsCreateRequest, options?: AxiosRequestConfig): AxiosPromise<BasketItem> {
            return localVarFp.paymentsBasketsItemsCreate(requestParameters.basket, requestParameters.BasketItem, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for BasketItem
         * @param {PaymentsApiPaymentsBasketsItemsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsItemsDestroy(requestParameters: PaymentsApiPaymentsBasketsItemsDestroyRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.paymentsBasketsItemsDestroy(requestParameters.basket, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for BasketItem
         * @param {PaymentsApiPaymentsBasketsItemsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsItemsList(requestParameters: PaymentsApiPaymentsBasketsItemsListRequest, options?: AxiosRequestConfig): AxiosPromise<PaginatedBasketItemList> {
            return localVarFp.paymentsBasketsItemsList(requestParameters.basket, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Basket
         * @param {PaymentsApiPaymentsBasketsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsList(requestParameters: PaymentsApiPaymentsBasketsListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaginatedBasketList> {
            return localVarFp.paymentsBasketsList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Basket
         * @param {PaymentsApiPaymentsBasketsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsBasketsRetrieve(requestParameters: PaymentsApiPaymentsBasketsRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<Basket> {
            return localVarFp.paymentsBasketsRetrieve(requestParameters.username, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle webhook call from the payment gateway when the user has completed a transaction.  Returns:     - HTTP_200_OK if the Order is found.  Raises:     - Http404 if the Order is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCheckoutCallbackCreate(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.paymentsCheckoutCallbackCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Start the checkout process. This assembles the basket items into an Order with Lines for each item, applies the attached basket discounts, and then calls the payment gateway to prepare for payment.  This is expected to be called from within the Ecommerce cart app, not from an integrated system.  Returns:     - JSON payload from the ol-django payment gateway app. The payment       gateway returns data necessary to construct a form that will       ultimately POST to the actual payment processor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCheckoutStartCheckoutCreate(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.paymentsCheckoutStartCheckoutCreate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for paymentsBasketsCreateFromProductCreate operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsCreateFromProductCreateRequest
 */
export interface PaymentsApiPaymentsBasketsCreateFromProductCreateRequest {
    /**
     *
     * @type {string}
     * @memberof PaymentsApiPaymentsBasketsCreateFromProductCreate
     */
    readonly sku: string

    /**
     *
     * @type {string}
     * @memberof PaymentsApiPaymentsBasketsCreateFromProductCreate
     */
    readonly system_slug: string
}

/**
 * Request parameters for paymentsBasketsItemsCreate operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsItemsCreateRequest
 */
export interface PaymentsApiPaymentsBasketsItemsCreateRequest {
    /**
     *
     * @type {string}
     * @memberof PaymentsApiPaymentsBasketsItemsCreate
     */
    readonly basket: string

    /**
     *
     * @type {BasketItem}
     * @memberof PaymentsApiPaymentsBasketsItemsCreate
     */
    readonly BasketItem: BasketItem
}

/**
 * Request parameters for paymentsBasketsItemsDestroy operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsItemsDestroyRequest
 */
export interface PaymentsApiPaymentsBasketsItemsDestroyRequest {
    /**
     *
     * @type {string}
     * @memberof PaymentsApiPaymentsBasketsItemsDestroy
     */
    readonly basket: string

    /**
     *
     * @type {string}
     * @memberof PaymentsApiPaymentsBasketsItemsDestroy
     */
    readonly id: string
}

/**
 * Request parameters for paymentsBasketsItemsList operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsItemsListRequest
 */
export interface PaymentsApiPaymentsBasketsItemsListRequest {
    /**
     *
     * @type {string}
     * @memberof PaymentsApiPaymentsBasketsItemsList
     */
    readonly basket: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof PaymentsApiPaymentsBasketsItemsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof PaymentsApiPaymentsBasketsItemsList
     */
    readonly offset?: number
}

/**
 * Request parameters for paymentsBasketsList operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsListRequest
 */
export interface PaymentsApiPaymentsBasketsListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof PaymentsApiPaymentsBasketsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof PaymentsApiPaymentsBasketsList
     */
    readonly offset?: number
}

/**
 * Request parameters for paymentsBasketsRetrieve operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsRetrieveRequest
 */
export interface PaymentsApiPaymentsBasketsRetrieveRequest {
    /**
     *
     * @type {string}
     * @memberof PaymentsApiPaymentsBasketsRetrieve
     */
    readonly username: string
}

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * Clear the basket for the current user.  Returns:     Response: HTTP response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsBasketsClearDestroy(options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsBasketsClearDestroy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new basket item from a product for the currently logged in user. Reuse the existing basket object if it exists.  If the checkout flag is set in the POST data, then this will create the basket, then immediately flip the user to the checkout interstitial (which then redirects to the payment gateway).  Args:     system_slug (str): system slug     sku (str): product slug  POST Args:     quantity (int): quantity of the product to add to the basket (defaults to 1)     checkout (bool): redirect to checkout interstitial (defaults to False)  Returns:     Response: HTTP response
     * @param {PaymentsApiPaymentsBasketsCreateFromProductCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsBasketsCreateFromProductCreate(requestParameters: PaymentsApiPaymentsBasketsCreateFromProductCreateRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsBasketsCreateFromProductCreate(requestParameters.sku, requestParameters.system_slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new basket item.  Args:     request (HttpRequest): HTTP request  Returns:     Response: HTTP response
     * @param {PaymentsApiPaymentsBasketsItemsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsBasketsItemsCreate(requestParameters: PaymentsApiPaymentsBasketsItemsCreateRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsBasketsItemsCreate(requestParameters.basket, requestParameters.BasketItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for BasketItem
     * @param {PaymentsApiPaymentsBasketsItemsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsBasketsItemsDestroy(requestParameters: PaymentsApiPaymentsBasketsItemsDestroyRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsBasketsItemsDestroy(requestParameters.basket, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for BasketItem
     * @param {PaymentsApiPaymentsBasketsItemsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsBasketsItemsList(requestParameters: PaymentsApiPaymentsBasketsItemsListRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsBasketsItemsList(requestParameters.basket, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Basket
     * @param {PaymentsApiPaymentsBasketsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsBasketsList(requestParameters: PaymentsApiPaymentsBasketsListRequest = {}, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsBasketsList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view set for Basket
     * @param {PaymentsApiPaymentsBasketsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsBasketsRetrieve(requestParameters: PaymentsApiPaymentsBasketsRetrieveRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsBasketsRetrieve(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle webhook call from the payment gateway when the user has completed a transaction.  Returns:     - HTTP_200_OK if the Order is found.  Raises:     - Http404 if the Order is not found.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsCheckoutCallbackCreate(options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsCheckoutCallbackCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start the checkout process. This assembles the basket items into an Order with Lines for each item, applies the attached basket discounts, and then calls the payment gateway to prepare for payment.  This is expected to be called from within the Ecommerce cart app, not from an integrated system.  Returns:     - JSON payload from the ol-django payment gateway app. The payment       gateway returns data necessary to construct a form that will       ultimately POST to the actual payment processor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsCheckoutStartCheckoutCreate(options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsCheckoutStartCheckoutCreate(options).then((request) => request(this.axios, this.basePath));
    }
}
